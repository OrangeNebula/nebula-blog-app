import { Article } from '../domain/Article';
import { AbstractArticleRepository } from './AbstractArticleRepository';

const mockData = [
  {
    id: 1,
    title: '5년차 코파운더 개발자의 회고 - 시니어 개발자',
    contents: `

대학교를 졸업하고, 스타트업에 종사한지 이제 5년차가 되었다. 용기와 열정으로 무장했지만 실제로는 무지에 가까운 내가, 겁없이 시작하게 된 스타트업이었고, 너무나 당연하게도 쉽지 않은 길이였다. 없는 경력에 무엇을 하겠다는건지 무시 받기도 했고, 모든 개발 의사결정을 스스로 내려야 했고, 매 순간 확신이 서지도 않았다. 과거에 개발에는 그나마 자신이 있었다고 생각하고 있어서 좌절감도 더 컸던 것 같다. 5년이라는 시간이 길다면 길고, 부족하다면 부족한 시간이었지만, 많은 경험을 할 수 있는 시간이었고, 개인블로그를 통해 나의 생각을 조금식 정리해보고자 한다. 오늘은 어려웠던 상황에서 막연하게  “시니어 개발자가 있었더라면” 이란 희망사항을 계속 생각했던 경험이 떠올라, "시니어 개발자"에 대한 이야기를 해볼려고 한다.

개발자로써 뿐만 아니라, 스타트업 파운더로써, 항상 개발자 채용에 대해 고민을 많이 해왔던것 같다. 지금 이 순간에도 어떤 사람이 필요한지에 대해 항상 고민하고, 우리 조직의 역량 매트릭스에서 어떤 부분이 부족한지를 계속 생각하고 있다. 나의 성장, 구성원들의 성장, 조직의 성장을 위해서 항상 좋은 사람을 희망했었고, 그럴 수록 “시니어 개발자” 란 누구인가에 대해 생각을 많이 했던것 같다.

시니어 개발자에 대한 생각을 공유하기 위해선, 그 정의부터 조심스럽게 내려보면 좋을 것 같다. 시니어 개발자란 누구인가, 주니어와 시니어를 나누는 그 경계선은 무엇인가? 가장 쉽게는 연차를 생각 해 볼 수 있겠다. 조직마다 조금씩 다를 순 있겠지만 일반적으로 시니어 개발자에 대한 기대치를 생각해볼 때, 개발 도메인에 대해 얼마나 경험을 오래해왔는가를 보는것 같다. 그 이유는 좀 더 성숙한 해결책을 제시 할 수 있을 정도의 경험을 기대하기 때문일것 같은데, 연차는 이에 대한 경험을 증명할 수 있는 하나의 수치로 생각해볼 수 있을것 같다. 그러나 연차가 시니어 개발자임을 증명할 수 있는가, 를 역으로 물어본다면 적어도 내 생각에는 부족함이 있는것 같다. 높은 연차를 지녔음에도 조직의 기대치에 미치지 못하는 개발자가 있을 수도 있고, 높은 연차가 아님에도 하이 퍼포머일 수도 있다.

두번째로 생각해볼 수 있는건, 작성하는 코드에 대한 품질일것 같다. 내가 속한 스타트업 환경 특성상 개발자의 업무 전선이 상당히 넓은게 특징이긴 하지만, 결국 본질은 코드인것 같다. 개발자에게 순수한 업무를 생각해보면, 코드를 “읽고”, “작성하고” 인데, 이 업무를 잘한다는 의미는 “잘 읽고”, “잘 작성하고” 일것 같고, “잘 작성” 한다는건 적시에 높은 품질의 코드를 만드는것으로 생각해볼 수 있기 때문이다. 이렇게 보면 시니어 개발자는 어떤 코드를 작성하느냐의 측면으로 보는것도 일리가 있는것 같다. 그러나 이 역시 생각해야 할 부분이 많은 것 같다. 언급한대로, 개발자의 업무전선, 요구되는 역량들은 많은것 같다. 개발자는 코드에 대한 부분 뿐만 아니라, 적극적으로 커뮤니케이션 하고, 조직 상황을 이해하고, 개발사항을 검토하고, 서비스를 운영하는 등, 다양한 업무를 진행하기 때문이다. 따라서 “시니어 개발자는 좋은 코드를 작성하는 사람이다.” 라고 생각하기에는 조직 상황에 따라 너무 일반화한 정의가 될 수도 있을것 같다. 특히 빠르게 성장하고, 생존을 고민하는 스타트업 입장에서 코드 품질에 대한 고민을 할 여유가 없을 때가 많다. 당장의 생존을 눈앞에두고, 개발자가 다른 업무는 뒷전에 둔 채 코드 품질만 고민하고 있다면 높은 확률로 조직의 상황을 잘 이해하고 있지 않을것 같고, 조직에서 기대하는 “시니어 개발자”의 모습은 아닐것 같다.

세번째로 생각해볼 수 있는 시니어 개발자의 기준은 지식 수준이 될 수도 있을것 같다. 툴에 대한 지식, 디자인 패턴에 대한 지식, 기술에 대한 지식 등, 조직이 해결해야 할 문제들에 도움이 될 수 있는 다양한 지식을 알고 있는 사람으로 정의하는 것이다. 예를 들어 검색 기능을 고도화해야 하는 문제로 고민하고 있는 조직에게, 검색 엔진에 대한 지식을 갖춘 개발자는 매력적인 인재일 수 있을것 같다. 빠르고 독립적인 배포환경을 구축하고 싶은 조직 입장에서는 그에 걸맞는 데브옵스 환경을 경험하고, 적절한 지식을 갖춘 개발자를 채용하고 싶을 것 같다. 또한 조직에서 어떻게 개발을 할 것인지에 대한 “개발 방향성” 을 제시하기 위해선, 적절한 경험과 지식을 겸비해야 할 것 같은데, 이 맥락에서 보면 시니어 개발자의 기준으로 지식 수준은 합리적일지도 모르겠다.

마지막으로는 매니징 역량일듯 하다. 나 역시 매니징에 대한 이해도가 낮고 잘하고 있다고 생각하지 않기에, 정의내리는게 상당히 어렵다. 또한 조직마다 요구되는 매니징 역량이 다를것 같다. 그래도 조심스럽게 내가 생각하는 매니징에 대한 생각을 얘기해보면, 아래의 요소들이 있을것 같다.

-   구성원들의 건강성을 주기적으로 체크하고, 업무에 집중할 수 있는 환경을 구성해준다.
-   조직의 미래에 관심갖게 하고, 동기부여하며, 조직과 구성원간 Align 된 의사결정을 할 수 있도록 돕는다.
-   주기적으로 구성원들과 1:1로 면담을 가져서, 적시에 피드백을 전달하거나 개별적 고려를 할 수 있다.
-   구성원의 성장을 위해 적극적으로 돕는다.

위에 열거된 요소들 외에도, 자기가 알고 있는 지식이나 경험을 팀에 공유하여 팀차원의 학습이 이루어질 수 있도록 전파하는것이나, 병목을 관측하고 원인을 식별하여 그 구간을 뚫어줄 수 있는것들도 있을것 같다. 조직에서 “시니어 개발자” 를 구인한다면 위에 열거된 요소들에 대한 기대치를 가지고 있을 확률이 높을것 같다.

시니어 개발자의 기준을 생각하기 위해, 연차(경험), 코드, 지식, 매니징, 크게 4가지 항목을을 이야기했다. 확실한것은 어떤 한가지 항목으로만 시니어 개발자를 정의하는 것은 쉽지도 않고, 조직에서 요구하는 기대치에 맞지 않다는 것일것 같다. 또한 조직에서 요구하는 것이 무엇인지, 어떤점을 기대하는지, 어떤 개발자를 좋은 개발자라고 생각하는지, 등에 따라 기대하는 “시니어 개발자”의 “상” 또한 다를 수 있는 점이 있다. 이런 한계를 먼저 인지한 다음… 조심스럽게 “시니어 개발자” 의 내가 생각하는 정의를 내려본다면, 조직에서 요구하는 경험과 지식 수준을 갖추고, 좋은 품질의 코드를 고민하며, 구성원들을 매니징 할 수 있는 개발자라고 생각할 수 있지 않을까 한다. 시니어 개발자에 대해 얕게나마 정의를 해보았는데, 그럼 자연스럽게 시니어 개발자에게 요구되는 기대치를 충족하기 위해 어떻게 성장할 수 있을지에 대한 질문이 떠오른다. 이에 대해서는 다음 글에 정리해보겠다.
    `,
    createdAt: '2021-05-20',
    updatedAt: '2021-05-20',
  },
  {
    id: 2,
    title: '5년차 코파운더 개발자의 회고 - 개발자로써의 성장',
    contents: `

지난 글에서 어렴풋하게 내가 생각하는 시니어 개발자의 정의를 내려보았다. 다음 글로는 그런 시니어 개발자의 정의에 부합하는 성장을 하기 위해서는 어떻게 해야 할 것인지에 대한 이야기가 이어져야 자연스러울 것 같다. 이 역시 쉽게 이야기 할 내용은 내용은 아니라고 생각한다. 다양한 성장 방향이 있고, 성장 그 자체에 대한 정의에 다른 의견이 있을 수 있기 때문이다. 그래도 내가 생각하는 몇가지를 정리해보면 세 가지가 있다.

첫번째로 경험에 대한 부분이다. 경험은 책이나 다른 매체로 간접적으로 접할 수 있는 부분도 있지만, 가장 좋은 경험은 몸으로 부딪혀가며 얻은 경험이 가장 값지다. 그 이유는 간접적으로 접한 경험의 경우는 자기것으로 만들기 어려울 때가 많고, 내 머리속에 각인되기 어려워 휘발될 수도 있기 때문이다. 나 역시도 많은 대가를 지불하면서 몸으로 배운 경험은 아직까지 잘 잊지 않는 반면, 책으로 접한 경험은 머리로는 이해해도, 내 행동의 변화(학습의 결과)로 이어지기가 어려웠다. 어떤 경험을 하는지, 얼마나 대가를 지불하는지도 중요하다. 나에게 큰 변화를 주는 배움이 있는가 하면, 의미없이 시간을 보내는 경험이 있다. 짧은 시간 동안 밀도 높은 경험을 하는가 하면, 큰 값을 치뤄야만 경험해볼 수 있는 영역도 있다. 지금 내가 무엇이 부족하고, 그래서 어떤 경험을 해봐야겠다, 하는 자기인지를 통해야만 의미있는 경험을 해볼 수 있을것 같다. 습득해야 하는 기술 스택을 이런저런 토이 프로젝트를 진행하면서 경험해보거나, 마음 맞는 사람들과 사이드 프로젝트나 스터디를 해보면서 협업에 대한 경험을 해볼 수 있겠다. 물론 현업에서 요구하는 경험치를 채우는데는 한계가 있을 수 있다. 그러나 실무에서는 리스크가 따를 수 있는 새로운 시도나 실험을 안전하게 할 수 있다는 장점도 있고, 조직에서 채울 수 없었던 영역에 대한 경험도 계획 해 볼 수 있다. 물론 조직내에서 안전하게 경험하고, 성장할 수 있는 환경이 조성되어 있다면야 더할나위 없겠지만, 이런 환경을 조성하기엔 많은 노력과 시간이 든다. 이에 대해서는 다음에 더 정리해볼려고 한다.

두번째는 어떻게 코드 품질을 높일 수 있을까 인데, 이에 대해 답하기 위해선 어떤 코드가 좋은 코드인가에 대한 질문으로 연결된다. 이것 역시 어려운 주제이기에 다음에 더 깊게 생각을 정리해보면 좋겠다. 여기서는 개발자로써의 성장 측면에서만 간단하게 정리를 해보겠다. 수년간 "좋은 코드는 어떤 코드인가?" 에 대해서 많은 개발자들의 생각을 여쭤보고 다녔다. 일반적으로 생각하는 좋은 코드부터, 생각하지도 못한 창의적인 접근까지 다양한 정의를 들은것 같다. 그나마 지금까지 접한 정의들 중에 가장 마음이 가는 정의는 마이클 페더스의 레거시 코드 활용 전략이라는 책에서 얻은 "테스트가 용이한 코드" 였다. 코드는 기대한대로 동작해야 의미가 있다. 잘 읽히는 코드, 확장성 있는 코드, 관심사 분리가 잘 된 코드 등 좋은 코드의 다양한 조건들이 있겠지만, 결국 이 모든것은 요구사항대로 잘 동작하는것이 선행되고 난 후에야 이야기 될 수 있다. 그렇다면 어떻게 요구사항대로 잘 동작하는지 확인을 "잘" 할 수 있을까? 바로 테스트 코드가 도움을 줄 수 있다. 그럼 테스트 코드를 잘 작성하려면 어떻게 해야 할까? 테스트가 용이해야 할 것이다. 코드가 테스트에 용이하다면, 테스트 코드를 잘 작성할 수 있을것이고, 테스트 코드를 이용하여 내가 코드를 잘 작성했는지 빠르게 동작여부에 대한 피드백을 받을 수 있다. 또한 버그 픽스에 드는 시간도 줄 일 수 있다(일반적으로 나중에 발견되는 버그일 수록 더 고통스러운 대가를 치르는것 같다). 좋은 코드에 대한 생각은 개발자들마다 다를 수 있다. 핵심은 내가 테스트가 용이한 코드가 좋은 코드라고 생각하는 것처럼, 좋은 코드란 무엇인지? 내가 작성하는 코드가 좋은 코드가 되기 위해선 어떻게 해야하는지? 치밀하게 고민해보는 것, 그것이 바로 핵심이 되겠다.

세번째는 지식 수준이다. 기술에 대한 지식 수준은 정보를 더 많이 가지고 있는 시니어가 유리한건 당연하다. 그러나 시간에 따라서 기술은 변한다(물론 기술마다 차이가 있다). 그 말은 새로운 기술일 수록 시니어와 주니어 둘 다 새로운 출발점을 지나야 하기에, 해당 기술에 대해서는 지식 수준이 큰 차이가 나지 않을 수도 있다. 또한 같은 지식을 접해도 사람마다 이해하는 시간, 내것으로 만드는 시간, 활용으로 넘어가는 시간 다르다. 이 말은 현재의 지식의 수준도 중요하지만, 지식 수준을 높이는 러닝 어질리티가 중요하다는 이야기가 된다. 과연 시니어가 무조건 러닝 어질리티가 높다고 볼 수 있을까? 그것은 또 다른 주제일것 같다. 확실한건, 지식은 시간에 따라 변하기 때문에 시니어가 모든 정보를 알 고 있기는 힘들고, 그런 무리한 기대를 해서도 안되며, 반대로 주니어는 기술 지식 수준이 낮을거라는 억측을 해서도 안된다는 것이다. 지식 수준은 계속해서 배우고 내 것으로 만들기 위해 끊임없이 노력해야 한다. 관심있는 기술 블로그를 주기적으로 확인하고, 책을 읽고, 내 기술 스택의 업데이트 사항들을 f/up 하고... 개발자는 평생 공부해야 한다는 이야기가 허투로 말하는게 아닌 이유가 여기에 있다고 본다.

이렇게 성장에 대한 세가지 꼭지를 살펴보았다. 개발자는 평생 공부해야 한다는 이야기에서도 느껴지지만, 참 공부해야 할 것도 많고, 갖춰야 할 것도 많다. 스타트업 초반에 나에게 요구되는 것들이 너무나도 많았기 때문에 정말 힘들었다. 고객은 내 역량 수준이나 상태에 대한 이해가 아니라 서비스에 대한 기대치만이 있을 뿐이다. 서비스의 성장은 나의 성장을 기다려주지 않는다. 어떻게든 그런 기대치를 맞추기 위해 발버둥을 쳤지만... 결국에는 성장한 시니어 개발자가 나를 리딩해주었으면 하는 막연한 기대를 갖게 되었던것 같다. 같은 개발자들을 어떻게 대하고, 함께 성장하기 위해선 어떻게 해야하는지, 혹은 성장을 도와주기 위해선 어떻게 해야 하는지, 나는 어떻게 성장해야 하는지, 정말 고민이 많았다. 같은 고민을 가진 개발자가 많을 거라 생각한다. 그래서 이런 개발자들에게 하고 싶었던 내용을 다음글에 정리해보고자 한다. 

    `,
    createdAt: '2021-05-21',
    updatedAt: '2021-05-21',
  },
  {
    id: 3,
    title: '5년차 코파운더 개발자의 회고 - 성장하는 개발자에게',
    contents: `
      
이전 글에서는 시니어 개발자와 시니어가 되기 위한 성장 토픽을 다루었다. 이야기한대로 개발자에게 요구되는 역량, 지식 등이 있고, 그러한 기대치를 맞추기 위해 어떤 경험을 해야 하는지, 어떤 고민을 해야 하는지 등이 있다. 이 모두 하나 하나 어려운 주제이다. 나를 비롯한 많은 개발자가 이런 주제로 고민을 하고 있다. 그런 과정은 힘들고 어려운 길이기에, 내가 그랬던 것처럼 막연하게 시니어 개발자가 있었으면 좋겠다는 기대를 가질 수 있다. 이 글에서는 나를 포함한 그런 개발자에게 해주고 싶은 이야기를 해보고자 한다.       
      
18년도 즈음이었던 듯 하다. 몸담은 스타트업 조직에서 모놀리틱 웹 애플리케이션 하나를 운영하고 있었다. 그때의 상황은 이것저것 실험해봐야 할 기능들, 고도화 해야 할 기능들 등, 해야 할 작업들이 점점 비대해져가고 있었고, 웹 애플리케이션이 다양한 관심사를 함께 가지고 있다보니 복잡하기도 했다. 그래서 API 개발자 한명을 구인하고, API 와 웹을 분리 하자는 결정을 내렸다. 나는 리쿠르팅에 미숙했기에 이런 결정 조차 쉽지 않았다. 어쨌든 API 개발자를 구했고, 웹 애플리케이션으로 부터 API 를 분리하는 작업을 시작했다. 되돌이켜보면 고통스러운 작업이었다. 기능개발은 계속 진행하면서, 분리작업은 분리작업대로 진행해야 했고, 필요한 어드민 기능이 미흡하다보니 운영 업무도 만만치 않았다. 나를 위해 스타트업으로 왔던 친구 개발자가 이런저런 도움을 많이 주었다. 분리작업은 3~4주 정도 걸렸던 듯 하다. 서버와 클라이언트의 관심사를 분리한 결과, 복잡도나 코드 생산성에 있어서 그런대로 만족스러웠다. 하지만 그 이후 많은 어려움이 뒤따르기 시작했다.

가장 먼저 기억나는건 구인했던 API 개발자와의 충돌이 잦아지기 시작했다는 점이다. 다음해에 앱 개발을 진행하기로 했고, 앱에 추천 기능을 신규로 넣어보자고 했는데, 그 방향성에 대한 의견이 달랐다. API 개발자가 자신의 의견을 굽히지 않자, 나는 앱이 서버에 주는 로드나, API 호출수, 그 외 병목 지점등을 테스트를 해서 리포트를 만들었고, 그 API 개발자의 의견에 조목조목 반박을 하면서 나의 의견에 힘을 실었다. 만약 이 글을 읽고 있는 당신이 매니징에 몸담고 있다면, 이후 상황을 예상하고 있을지도 모르겠다. 데이터에 입각하여 논리적으로 상대방의 의견을 철저하게 누른 결과, 그 API 개발자의 모티베이션이나 심리적 안전함, 나와의 신뢰 관계에 많은 금이 갔다. 물론 그 당시의 나는 그런걸 깨닫지 못했기에, 내가 주장한 방향대로 개발을 진행했다. 그 API 개발자는 자신의 업무에 대한 몰입도나 조직 commitment 가 떨어지기 시작했고, 이듬해 퇴사를 하였다. 그 이후 친구 개발자와도 이런저런 갈등을 빚어왔다. 상당히 힘들었다. 내가 하고 있는 개발 업무도 잘하고 있는지 확신이 들지 않는데, 구성원들과 어떻게 신뢰를 쌓고, 어떻게 매니징을 해야 할 지 전혀 감이 오지 않았다. 그럴수록, 시니어 개발자가 있었으면 좋겠다, 는 희망사항을 가졌었다.
 
조직에서 풀고자 하는 문제가 있고, 이 문제를 풀기 위해 기대되는 역량 수준이 시니어 정도라면 당연히 구인을 해야 한다. 하지만 내가 그 상황에서 시니어 개발자를 구인했을 때, 과연 성공적이었을까? 지금 생각해보면 그럴 확률이 낮다고 생각한다. 내 기대치가 명확하지 않은채로, 내가 가지고 있는 어려움이 힘들다는 이유로, 그것을 대신할 사람이 왔으면 좋겠다는 정도로 리쿠르팅을 시도한다면 좋은 사람을 찾기도 힘들도 기약없는 바램이 될 가능성이 높다고 생각한다. 

구직 활동을 하는 주니어 개발자들의 이야기를 들어보면, “내가 성장하고 배울 수 있는 사람이 있는가?” 가 빠지지 않는것 같다. 나 역시 혼자 모든것을 의사결정해야 했던 캄캄한 상황에서, 누군가 옆에서 해결해주고 도와주고 이끌어주면 좋겠다고 생각했다. 내가 성장하기 위해서는 배울 수 있는 사람이 조직에 있었으면 했다. 그렇기에 성장 고민을 하고 있는 주니어 개발자들의 이야기에 많이 공감한다. 그런 생각을 가지고 모든것이 미숙했던 주니어 개발자가, 조금은 성장해서(지금도 많이 부족하지만...) 자신의 성장 경험을 공유해보고자 글을 쓰고 있다. 나도 이렇게 조금씩 내가 생각하는 시니어 개발자의 상을 잡고, 어떻게 성장하고 학습해야 할 지 이것저것 시도해보는데, 이 글을 읽고 있는 여러분이라고 못 할 것이 무엇인가. 내가 배울 수 있는 사람을 갈망하는 것처럼, 여러분도 누군가에게 있어 배우고 싶은 사람이 될 수 있다.

스포일러일 수도 있지만, 영화 이야기를 하나 하고 싶다. 해리포터와 아즈카반의 죄수편인데, 어렸을 때 판타지 영화를 워낙 좋아해서 그랬는지 정말 재밌게 본 것 같다. 그런데 뒤돌아서 어른이 된 시점에서 생각해보니 인상깊은 장면이 하나가 있다. 해리가 시리우스를 구해내는 장면이다. 해리가 시리우스를 구하기 위해 디멘터(해리포터를 모르는 분에게는.. 간수라고 설명하면 될까?)를 막다가 힘이 다해버리는데, 그 때 호수 건너편에서 누군가 해리를 도와준다. 해리는 그게 자신의 아버지라고 생각하지만, 사실은 미래의 해리가 시간을 건너와 바로 자기 자신을 도운것이었다.

![](https://cdn-images-1.medium.com/max/1200/1*GMmY4TYGfJ-WsDIwwP2H7w.jpeg)

뒤돌아서 보니 인상깊었던 이유는, 다른 누구의 압도적인 도움으로 문제를 해결한게 아니라, 내가 성장하여 바로 자기 자신을 구해내는 점이였기 때문이다. 나 역시 어느정도 시간이 지난즈음 나를 돌이켜보니, 시니어 개발자가 나에게 해주었음 하고 기대했던 것들을, 다른 구성원들에게 하고 있더라. 시니어 개발자를 갈구하면서도, 그 상황을 이겨내기 위해 어떻게든 성장하려고 했던 과거의 자신이, 오늘의 나를 만들었다고 생각한다. 해리포터 이야기처럼, 지금 이 순간의 나를 돕고 있는건, 결국 나 자신이라 생각한다. 앞이 깜깜하고, 어떻게 해야 할 지 모르겠고, 막막했던 시간들이 많았다. 그러나 항상 벽을 더듬어가며 문고리를 찾아왔고, 문을 열고 어찌어찌 걸어왔다. 누군가 문을 열어주길 기대했지만, 문을 연건 나 자신이였다. 내가 항상 잘해왔다는건 아니다. 나 역시도 주변의 많은 도움을 받아왔다. 여기서 얘기하고 싶은건, 나도 할 수 있다는 의지를 가지고, 도움의 손길을 적극적으로 잡아가며 성장해나가는 것이다. 위에도 이야기 했지만, 나를 포함한 많은 개발자에게 이야기해주고 싶은것은, 여러분도 할 수 있다, 는 것이다. 
    `,
    createdAt: '2021-05-22',
    updatedAt: '2021-05-22',
  },
];

export default class ArticleRepositoryMock extends AbstractArticleRepository {
  get(): Promise<Article[]> {
    return Promise.resolve(
      mockData.sort((a, b) => (a.id < b.id ? 1 : -1)).map((item) => (
        new Article(
          item.id,
          item.title,
          item.contents,
          new Date(item.createdAt),
          new Date(item.createdAt || item.updatedAt),
        )
      )),
    );
  }

  find(id: number): Promise<Article | null> {
    const data = mockData.find((item) => item.id === id);
    if (!data) {
      return Promise.resolve(null);
    }
    return Promise.resolve(new Article(
      data.id,
      data.title,
      data.contents,
      new Date(),
      new Date(),
    ));
  }

  update(item: Article): Promise<void> {
    return Promise.resolve(undefined);
  }
}
