import { Article } from '../domain/Article';
import { AbstractArticleRepository } from './AbstractArticleRepository';

const mockData = [
  {
    id: 1,
    title: '5년차 코파운더 개발자의 회고 - 시니어 개발자(1)',
    contents: `

대학교를 졸업하고, 스타트업에 종사한지 이제 5년차가 되었다. 용기와 열정으로 무장했지만 실제로는 무지에 가까운 내가, 겁없이 시작하게 된 스타트업이었고, 너무나 당연하게도 쉽지 않은 길이였다. 없는 경력에 무엇을 하겠다는건지 무시 받기도 했고, 모든 개발 의사결정을 스스로 내려야 했고, 매 순간 확신이 서지도 않았다. 과거에 개발에는 그나마 자신이 있었다고 생각하고 있어서 좌절감도 더 컸던 것 같다. 5년이라는 시간이 길다면 길고, 부족하다면 부족한 시간이었지만, 많은 경험을 할 수 있는 시간이었고, 개인블로그를 통해 나의 생각을 조금식 정리해보고자 한다. 오늘은 어려웠던 상황에서 막연하게  “시니어 개발자가 있었더라면” 이란 희망사항을 계속 생각했던 경험이 떠올라, "시니어 개발자"에 대한 이야기를 해볼려고 한다.

개발자로써 뿐만 아니라, 스타트업 파운더로써, 항상 개발자 채용에 대해 고민을 많이 해왔던것 같다. 지금 이 순간에도 어떤 사람이 필요한지에 대해 항상 고민하고, 우리 조직의 역량 매트릭스에서 어떤 부분이 부족한지를 계속 생각하고 있다. 나의 성장, 구성원들의 성장, 조직의 성장을 위해서 항상 좋은 사람을 희망했었고, 그럴 수록 “시니어 개발자” 란 누구인가에 대해 생각을 많이 했던것 같다.

시니어 개발자에 대한 생각을 공유하기 위해선, 그 정의부터 조심스럽게 내려보면 좋을 것 같다. 시니어 개발자란 누구인가, 주니어와 시니어를 나누는 그 경계선은 무엇인가? 가장 쉽게는 연차를 생각 해 볼 수 있겠다. 조직마다 조금씩 다를 순 있겠지만 일반적으로 시니어 개발자에 대한 기대치를 생각해볼 때, 개발 도메인에 대해 얼마나 경험을 오래해왔는가를 보는것 같다. 그 이유는 좀 더 성숙한 해결책을 제시 할 수 있을 정도의 경험을 기대하기 때문일것 같은데, 연차는 이에 대한 경험을 증명할 수 있는 하나의 수치로 생각해볼 수 있을것 같다. 그러나 연차가 시니어 개발자임을 증명할 수 있는가, 를 역으로 물어본다면 적어도 내 생각에는 부족함이 있는것 같다. 높은 연차를 지녔음에도 조직의 기대치에 미치지 못하는 개발자가 있을 수도 있고, 높은 연차가 아님에도 하이 퍼포머일 수도 있다.

두번째로 생각해볼 수 있는건, 작성하는 코드에 대한 품질일것 같다. 내가 속한 스타트업 환경 특성상 개발자의 업무 전선이 상당히 넓은게 특징이긴 하지만, 결국 본질은 코드인것 같다. 개발자에게 순수한 업무를 생각해보면, 코드를 “읽고”, “작성하고” 인데, 이 업무를 잘한다는 의미는 “잘 읽고”, “잘 작성하고” 일것 같고, “잘 작성” 한다는건 적시에 높은 품질의 코드를 만드는것으로 생각해볼 수 있기 때문이다. 이렇게 보면 시니어 개발자는 어떤 코드를 작성하느냐의 측면으로 보는것도 일리가 있는것 같다. 그러나 이 역시 생각해야 할 부분이 많은 것 같다. 언급한대로, 개발자의 업무전선, 요구되는 역량들은 많은것 같다. 개발자는 코드에 대한 부분 뿐만 아니라, 적극적으로 커뮤니케이션 하고, 조직 상황을 이해하고, 개발사항을 검토하고, 서비스를 운영하는 등, 다양한 업무를 진행하기 때문이다. 따라서 “시니어 개발자는 좋은 코드를 작성하는 사람이다.” 라고 생각하기에는 조직 상황에 따라 너무 일반화한 정의가 될 수도 있을것 같다. 특히 빠르게 성장하고, 생존을 고민하는 스타트업 입장에서 코드 품질에 대한 고민을 할 여유가 없을 때가 많다. 당장의 생존을 눈앞에두고, 개발자가 다른 업무는 뒷전에 둔 채 코드 품질만 고민하고 있다면 높은 확률로 조직의 상황을 잘 이해하고 있지 않을것 같고, 조직에서 기대하는 “시니어 개발자”의 모습은 아닐것 같다.

세번째로 생각해볼 수 있는 시니어 개발자의 기준은 지식 수준이 될 수도 있을것 같다. 툴에 대한 지식, 디자인 패턴에 대한 지식, 기술에 대한 지식 등, 조직이 해결해야 할 문제들에 도움이 될 수 있는 다양한 지식을 알고 있는 사람으로 정의하는 것이다. 예를 들어 검색 기능을 고도화해야 하는 문제로 고민하고 있는 조직에게, 검색 엔진에 대한 지식을 갖춘 개발자는 매력적인 인재일 수 있을것 같다. 빠르고 독립적인 배포환경을 구축하고 싶은 조직 입장에서는 그에 걸맞는 데브옵스 환경을 경험하고, 적절한 지식을 갖춘 개발자를 채용하고 싶을 것 같다. 또한 조직에서 어떻게 개발을 할 것인지에 대한 “개발 방향성” 을 제시하기 위해선, 적절한 경험과 지식을 겸비해야 할 것 같은데, 이 맥락에서 보면 시니어 개발자의 기준으로 지식 수준은 합리적일지도 모르겠다.

마지막으로는 매니징 역량일듯 하다. 나 역시 매니징에 대한 이해도가 낮고 잘하고 있다고 생각하지 않기에, 정의내리는게 상당히 어렵다. 또한 조직마다 요구되는 매니징 역량이 다를것 같다. 그래도 조심스럽게 내가 생각하는 매니징에 대한 생각을 얘기해보면, 아래의 요소들이 있을것 같다.

-   구성원들의 건강성을 주기적으로 체크하고, 업무에 집중할 수 있는 환경을 구성해준다.
-   조직의 미래에 관심갖게 하고, 동기부여하며, 조직과 구성원간 Align 된 의사결정을 할 수 있도록 돕는다.
-   주기적으로 구성원들과 1:1로 면담을 가져서, 적시에 피드백을 전달하거나 개별적 고려를 할 수 있다.
-   구성원의 성장을 위해 적극적으로 돕는다.

위에 열거된 요소들 외에도, 자기가 알고 있는 지식이나 경험을 팀에 공유하여 팀차원의 학습이 이루어질 수 있도록 전파하는것이나, 병목을 관측하고 원인을 식별하여 그 구간을 뚫어줄 수 있는것들도 있을것 같다. 조직에서 “시니어 개발자” 를 구인한다면 위에 열거된 요소들에 대한 기대치를 가지고 있을 확률이 높을것 같다.

시니어 개발자의 기준을 생각하기 위해, 연차(경험), 코드, 지식, 매니징, 크게 4가지 항목을을 이야기했다. 확실한것은 어떤 한가지 항목으로만 시니어 개발자를 정의하는 것은 쉽지도 않고, 조직에서 요구하는 기대치에 맞지 않다는 것일것 같다. 또한 조직에서 요구하는 것이 무엇인지, 어떤점을 기대하는지, 어떤 개발자를 좋은 개발자라고 생각하는지, 등에 따라 기대하는 “시니어 개발자”의 “상” 또한 다를 수 있는 점이 있다. 이런 한계를 먼저 인지한 다음… 조심스럽게 “시니어 개발자” 의 내가 생각하는 정의를 내려본다면, 조직에서 요구하는 경험과 지식 수준을 갖추고, 좋은 품질의 코드를 고민하며, 구성원들을 매니징 할 수 있는 개발자라고 생각할 수 있지 않을까 한다. 시니어 개발자에 대해 얕게나마 정의를 해보았는데, 그럼 자연스럽게 시니어 개발자에게 요구되는 기대치를 충족하기 위해 어떻게 성장할 수 있을지에 대한 질문이 떠오른다. 이에 대해서는 다음 글에 정리해보겠다.
    `,
  },
  {
    id: 2,
    title: '5년차 코파운더 개발자의 주저리 주저리 - 시니어 개발자(2) - 시니어 개발자로써의 성장',
    contents: `
      어렴풋하게 내가 생각하는 시니어 개발자의 정의를 내려보았다. 이 정의에 부합하는 성장을 하기 위해서는 어떻게 할 것인지에 대한 이야기가 이어져야 자연스러울 것 같다. 이 역시 쉽게 이야기 할 내용은 아닌 것 같다. 내가 생각하는 정의와 다른 의견이 있을 수도 있고, 성장의 방향 역시 한 갈래가 아니기 때문이다. 그래도 내가 생각하는 몇가지를 정리해보면 세가지 정도가 있을것 같다.
가장 먼저 경험의 영역은 이런 저런 시도를 해보면서 경험적으로 습득하는것이 좋은것 같다. 단순히 책이나, 다른 사람의 가르침으로부터 전달되는 정보로 경험치를 쌓는데에는 충분하지 않을 수 있다. 혼자 이런저런 토이 프로젝트를 진행해보거나, 마음 맞는 사람들과 사이드 프로젝트나 스터디를 해보면서 몸으로 익혀나가는게 도움이 되는것 같다. 물론 현업에서 요구하는 경험치를 채우는데는 한계가 있을 수 있지만, 실무에서는 리스크가 따를 수 있는 새로운 시도나 실험을 안전하게 할 수 있다는 장점도 있다. 물론 조직내에서 안전하게 경험하고, 성장할 수 있는 환경이 조성되어 있다면야 더할나위 없겠지만, 이런 환경을 조성하기엔 많은 노력과 시간이 든다. 이에 대해서는 다음에 더 정리해볼려고 한다.
두번째는 어떻게 코드 품질을 높일 수 있을까 인데, 이에 대해 답하기 위해선 어떤 코드가 좋은 코드인가에 대한 질문으로 연결된다. 이 역시 이야기하기 쉽진 않은것 같고, 이것을 주제로 따로 생각을 정리해볼려고 한다. 수년간 "좋은 코드는 어떤 코드인가?" 에 대해서 많은 개발자들의 생각을 여쭤보고 다녔다. 일반적으로 생각하는 좋은 코드부터, 생각하지도 못한 창의적인 해석까지 다양한 정의를 들은것 같다. 그나마 지금까지 접한 정의들 중에 가장 마음이 가는 정의는 마이클 페더스의 레거시 코드 활용 전략이라는 책에서 얻은 "테스트가 용이한 코드" 였다. 코드는 결국 기대한대로 잘 동작해야 의미가 있다. 잘 읽히는 코드, 확장성 있는 코드, 관심사 분리가 잘 된 코드 등 좋은 코드의 다양한 조건들이 있겠지만, 결국 이 모든것은 요구사항대로 잘 동작하는것이 선행되고 난 후에야 이야기 될 수 있다. 그렇다면 어떻게 요구사항대로 잘 동작하는지 확인을 "잘" 할 수 있을까? 테스트 코드가 많은 도움을 줄 수 있을것 같다. 그럼 테스트 코드를 잘 작성하려면 어떻게 해야 할까? 바로 테스트가 용이해야 할 것이다. 코드가 테스트에 용이하다면, 테스트 코드를 잘 작성할 수 있을것이고, 이 테스트 코드를 이용하여 내가 잘 코드를 작성했는지 빠르게 동작여부에 대한 피드백을 받을 수 있다. 또한 이 장점으로 버그 픽스에 드는 시간도 줄 일 수 있다(일반적으로 나중에 발견되는 버그일 수록 더 고통스러운 대가를 치르는것 같다). 내가 생각하는 좋은 코드와 품질에 대한 이야기로 옆길로 새긴 했지만, 결국에 좋은 코드에 대한 생각은 개발자들마다 다를 수 있다. 핵심은 내가 테스트가 용이한 코드가 좋은 코드라고 생각하는 것처럼, 좋은 코드란 무엇인지? 내가 작성하는 코드가 좋은 코드가 되기 위해선 어떻게 해야하는지? 치밀하게 고민해보는 것이 좋을 것 같다.
세번째는 지식 수준이다. 기술에 대한 지식 수준은 정보를 더 많이 가지고 연결할 수 있는 시니어가 더 유리한건 당연할 수 있을것 같다. 그러나 시간에 따라서 기술은 변한다(물론 기술마다 차이가 있다). 그 말은 새로운 기술일 수록 습득해야 하는 지식의 양이 주니어 개발자가 넘지 못할 정도로 많은건 아니라는 의미가 될 수도 있을것 같다. 또한 같은 지식을 접해도 사람마다 이해하는 시간, 내것으로 만드는 시간, 활용으로 넘어가는 시간이 다를 순 있다. 이 말은 단순히 지식의 수준을 넘어서, 지식 수준 그 자체를 높이는 러닝 어질리티가 더 중요할 수 있다는 이야기가 될 것 같다. 그럼 과연 시니어가 무조건 러닝 어질리티가 더 높다고 볼 수 있을까? 그것은 또 다른 주제일것 같다. 확실한건, 지식은 시간에 따라 변하기 때문에 시니어가 모든 정보를 알 고 있기는 힘들고, 그런 무리한 기대를 해서도 안되며, 반대로 주니어는 무조건 모른다는 억측을 해서도 안된다는 것이다. 계속해서 배우고 내 것으로 만들기 위해 끊임없이 노력해야 하고, 개발자는 평생 공부해야 한다는 이야기가 허투로 말하는게 아닌 이유가 이 이유에서 일 것 같다.
    `,
    createdAt: '2021-02-21 12:00',
    updatedAt: '2021-02-21 12:00',
  },
  {
    id: 3,
    title: '5년차 코파운더 개발자의 주저리 주저리 - 시니어 개발자(3) - 하고 싶은 말',
    contents: `
      
조직에서 풀고자 하는 문제가 있고, 이 문제를 풀기 위해 기대되는 역량 수준이 시니어 정도라면 당연히 구인을 해야 한다. 그러나 내가 막연하게 시니어 개발자를 고대했던 것처럼, 시니어 개발자에게 무엇을 기대하는지 명확하지 않은 채로 막연히 시니어 개발자를 기다리는건, 좋은 사람을 찾는데 실패할 확률도 높고, 기약 없는 바램이 되어버릴 것이다.

구직 활동을 하는 주니어 개발자들의 이야기를 들어보면, 찾고자 하는 조직의 조건중에 “내가 성장하고 배울 수 있는 사람이 있는가?” 가 빠지지 않는것 같다. 나 역시 혼자 모든것을 의사결정해야 했던 캄캄한 상황에서, 누군가 옆에서 해결해주고 도와주고 이끌어주면 좋겠다고 생각한적 있다. 모든것이 미숙했던 주니어 개발자가, 이제 한걸음 성장해서 자신의 성장 경험을 공유해보고자 글을 쓰고 있다. 나도 이렇게 조금씩 내가 생각하는 시니어 개발자의 상을 잡고, 어떻게 성장하고 학습해야 할 지 이것저것 시도해보는데, 이 글을 읽고 있는 여러분이라고 못 할 것이 무엇인가. 내가 배울 수 있는 사람을 갈망하는 것처럼, 여러분도 누군가에게 있어 배우고 싶은 사람이 될 수 있다.

스포일러일 수도 있지만, 영화 이야기를 하나 하고 싶다. 해리포터와 아즈카반의 죄수편인데, 어렸을 때 판타지 영화를 워낙 좋아해서 그랬는지 정말 재밌게 본 것 같다. 그런데 뒤돌아서 어른이 된 시점에서 생각해보니 인상깊은 장면이 하나가 있다. 해리가 시리우스를 구해내는 장면이다. 해리가 시리우스를 구하기 위해 디멘터(해리포터를 모르는 분에게는.. 간수라고 설명하면 될까?)를 막다가 힘이 다해버리는데, 그 때 호수 건너편에서 누군가 해리를 도와준다. 해리는 그게 자신의 아버지라고 생각하지만, 사실은 미래의 해리가 시간을 건너와 바로 자기 자신을 도운것이었다.

![](https://cdn-images-1.medium.com/max/1200/1*GMmY4TYGfJ-WsDIwwP2H7w.jpeg)

뒤돌아서 보니 인상깊었던 이유는, 다른 누구의 압도적인 도움으로 문제를 해결한게 아니라, 내가 성장하여 바로 자기 자신을 구해내는 점이였기 때문인것 같다. 나 역시 어느정도 시간이 지난즈음 나를 돌이켜보니, 시니어 개발자가 나에게 해주었음 하고 기대했던 것들을, 다른 구성원들에게 하고 있었던 것 같다. 시니어 개발자를 갈구하면서도, 그 상황을 이겨내기 위해 어떻게든 성장하려고 했던 과거의 자신이, 오늘의 나를 만들었던 것 같다. 해리포터 이야기처럼, 지금 이 순간의 나를 돕고 있는건, 결국 나 자신이라 생각한다. 앞이 깜깜하고, 어떻게 해야 할 지 모르겠고, 막막했던 시간들이 많았다. 그러나 항상 벽을 더듬어가며 문고리를 찾아왔고, 문을 열고 어찌어찌 걸어왔다. 누군가 문을 열어주길 기대했지만, 문을 연건 나 자신이였다. 내가 항상 잘해왔다는건 아니다. 나 역시도 주변의 많은 도움을 받아왔다. 여기서 얘기하고 싶은건, 나도 할 수 있다는 의지를 가지고, 도움의 손길을 적극적으로 잡아가며 성장해나가는 것이다. 위에도 이야기 했지만, 나와 비슷한 상황인 개발자에게 이야기해주고 싶은것은, 여러분도 할 수 있다, 는 것이다. 첫 글 치곤 약간 글이 긴 감이 있지만… 언젠가 글을 작성한다면 이 이야기를 가장 먼저 해보고 싶었다.
    `,
    createdAt: '2021-02-21 12:00',
    updatedAt: '2021-02-21 12:00',
  },
];

export default class ArticleRepositoryMock extends AbstractArticleRepository {
  get(): Promise<{ data: Article[]; next: string }> {
    return Promise.resolve({
      data: mockData.map((item) => (
        new Article(
          item.id,
          item.title,
          item.contents,
          new Date(),
          new Date(),
        )
      )),
      next: '',
    });
  }

  find(id: number): Promise<Article | null> {
    const data = mockData.find((item) => item.id === id);
    if (!data) {
      return Promise.resolve(null);
    }
    return Promise.resolve(new Article(
      data.id,
      data.title,
      data.contents,
      new Date(),
      new Date(),
    ));
  }

  update(item: Article): Promise<void> {
    return Promise.resolve(undefined);
  }
}
