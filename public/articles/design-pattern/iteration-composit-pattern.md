### 배경
서로 다른 방식으로 여러 아이템을 가지고 있는 클래스가 있다고 가정. 그런데 그 클래스들을 통합해서 사용해야 하는 경우가 발생했다. 이 경우 통합하여 사용할 수 있는 클래스를 선언할 순 있으나, 그 클래스는 내부적으로 사용하는 클래스와 강하게 의존도가 생기고, 캡슐화가 지켜지지 않을 것이며, 순회하는 코드들이 중복이 될 것이다.

### 이터레이터 패턴
디자인 원칙 중 중요한 것 하나는 "바뀌는 부분을 캡슐화 하라." 라는 것. 각 컬렉션에서의 반복(순회) 를 캡슐화하여 내부적으로 어떻게 구현되었는지 알지못하게 하면서, 반복(순회)를 할 수 있도록 하는 것이 이터레이션 패턴이다. 좀 더 정확하게는, 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체에 안에 있는 모든 항목에 접근할 수 있는 방법을 제공해주는 패턴이다. 이터레이터 패턴을 사용하면 집합체의 각 항목을 인터페이스를 이용하여 접근할 수 있게 되어서 유연해지기도 하고, 인터페이스 구현이 간단해진다.

### 단일 책임 원칙
클래스를 바꾸는 이유는 한 가지 뿐이어야 한다. 

### 컴포지트 패턴
이 패턴을 이용하면 계층 구조를 만들 수 있는데, 클라이언트에서 개별 객체와 복합 객체를 똑같은 방식으로 다룰 수 있게 해준다. 컴포지트 패턴은 SRP 원칙을 위배한다고 볼 수 있는데, 클라이언트에서 개별 객체와 복합 객체를 함께 다룰 수 있게 투명성을 확보할 수는 있지만, 개별 객체와 복합 객체가 구현하는 컴포지트 인터페이스는, 두 객체 모두에 대한 인터페이스를 제공해야 하기 때문이다. 따라서 개별 객체의 인터페이스, 복합 객체의 인터페이스 둘 모두를 고려해야 하고, 이는 단일 책임 원칙을 위배한다고 볼 수 있다. 그러나 SRP 를 지킬것인가, 투명성을 얻을 것인가는 상황에 맞게 디자인 원칙을 가져가야 한다. 컴포지트 패턴을 이용해서 개별/복합 객체를 순회할 때, 순회 코스트가 너무 큰 경우에는 복합 객체 내에 캐싱을 둘 수 도 있다.
