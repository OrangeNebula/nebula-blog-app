### 소프트웨어 변경
* 소프트웨어 코드 변경 이유
    * 새로운 기능 추가
    * 버그 수정
    * 설계 개선
    * 자원 이용의 최적화
* 소프트웨어 코드 변경을 숙지하고 있는것은 우리가 무엇에 집중해야 하는지 알려주는 이점이 있다.
* 하지만 변경 코드에만 집중해서는 안된다. 정말 문제가 되는 것은 코드를 변경할 때 어떤 동작에 영향을 미칠지 파악하기 매우 어려운 점이다.
* 위험한 변경을 최소화하기 위해 세가지 질문을 해야 한다.
    * 어떤 변경을 해야 하는가?
    * 변경이 정확하게 이루어졌는지 어떻게 확인 할 수 있는가?
    * 무언가를 손상시키지 않았는지를 어떻게 확인 할 수 있는가?
* 이런 위험이 크다면 구성원은 변경 회피를 하게 된다. 이런 변경 회피는 두려움이라는 문제로 다가온다. 그러나 변경을 회피하는 것은 나쁜 결과를 초래한다.
    * 기존의 클래스와 메소드는 비대해져갈 것 이다.
    * 개발자의 실력이 녹슬기 쉬워진다.
    * 변경 회피에 대한 두려움이 더 커진다.

### 피드백 활용
* 시스템을 변경하는 방법은 크게 2가지가 있다.
    * 변경하고 기도하기 (기도메타)
    * 보호 후 수정하기 (Cover and modify)
* 보호 후 수정하기는 안전망을 이용하는 것이다. 소프트웨어에 안전망을 두르는것은 데스트 루틴으로 코드를 덮는것이다.
* 피드백은 빠른 것이 좋다.
    * QA 팀이 발견해서 당신에게 이슈를 어사인하기까지는 시간이 걸린다.
    * 테스트 코드가 있다면, 당신은 몇 분만에 문제점이 있다는 것을 알 수 있다.
* 단위테스트
    * 시스템의 가장 원자적인 동작 단위를 의미
    * 함수나 클래스의 분리 테스트는 단위 테스트의 의미상 매우 중요
    * 단위테스트에 비해 대규모 테스트는 어려움이 있다.
        * 오류 위치를 파악하기가 어렵다.
        * 오랜 시간이 걸린다. 오래 걸리는 테스트는 결국 실행하지 않게 된다.
        * 새로운 코드가 추가된 경우, 그 코드를 실행하기 위한 상위 단계 테스트 루틴을 작성하기 위해 상당량의 코딩 작업이 요구 될 수 있다.
    * 단위테스트는 대규모 테스트의 단점을 보완할 수 있다. 단위테스트의 조건은 아래와 같다.
      * 실행 속도가 빠르다. 실행시간이 0.1초 이상 걸린다면 속도가 느리다!
      * 오류 위치 파악에 도움이 된다.
    * 아래의 경우는 단위 테스트가 아니다. 이런 테스트는 단위 테스트와 분리할 수 있어야 한다.
        * 데이터베이스 연동
        * 네트워크를 통해 통신
        * 파일 시스템을 사용
        * 테스트 실행을 위해 특별한 작업(e.g. 설정파일 변경) 을 해야 한다.
* 레거스 코드 프로젝트에서 변경 작업을 해야 한다면, 변경을 할 코드 주변에 테스트 루틴을 배치하자. 이것은 언제나 안전성을 높여줄 것이다.
* 레거시 코드를 변경하는 순서는 아래와 같다.
    * 변경 지점을 식별한다.
    * 테스트 루틴을 작성할 위치를 찾는다.
    * 의존 관계를 제거한다.
    * 테스트 루틴을 작성한다.
    * 변경 및 리팩토링을 수행한다. (TDD를 적극 권장한다)
    
### 감지와 분리

## 봉합 모델
단위 테스트를 위해 개별 클래스를 추출하려고 하면 대부분 수많은 의존 관계를 제거해야 한다. 
봉합 지점은 코드를 직접 편집하지 않고도 프로그램의 동작을 변경할 수 있는 위치를 말하는데, 이를 이용하면 테스트 코드를 작성할 수 있다.

또한 봉합에는 활성화 지점이 있다. 활성화 지점이란, 어떤 동작을 사용할 지 선택할 수 있는 지점이다. 봉합이 있다는 것은 동작을 변경시킬 수 있는 지점을 의미하는데, 우리가 실행할 코드의 변경 없이 동작을 변경한다는 것은 실행할 코드 이외에 지점에서 코드를 변경해야 한다는 의미이다. 그리고 그 지점이 바로 봉합의 활성화 지점이라 볼 수 있다.

### 전처리 봉합

### 링크 봉합
자바의 경우 CLASSPATH 를 통해 어떤 클래스를 사용할 것인지 결정할 수 있는 봉합을 이용할 수 있다. CLASSPATH 를 변경하는 것은 번거로운 일일 수 있지만, 의존관계를 제거하는데는 매우 유용하다.

혹은 특정 라이브러리를 임포트하고 있다면, 해당 라이브러리에 대한 스텁을 만들어서 사용하도록 함으로써 의존관계를 제거할 수 있다.

링크 봉합의 활성화 지점은 언제나 소스 코드의 외부에 위치한다. 링크봉합을 사용할 때는 테스트 환경과 제품(배포) 환경 간에 분명한 차이가 있도록 구성해야 한다.

### 객체 봉합
추상 클래스를 구현하는 여러 구상 클래스를 두면, 어떤 메소드가 실행이 될 지 알 수 없다. 즉 다른 코드의 변경 없이 호출되는 메소드의 액션을 변경시킬 수 있는 위치가 되는데, 이는 봉합 위치라고 볼 수 있다. 그러나 추상 클래스가 아니라 구상 클래스에 의존하게 되면, 이는 어떤 메소드가 호출될 것인지 직접적으로 알 고 있으므로 봉합 지점이 아니다.

## 고칠 것은 많고 시간은 없고
테스트 코드 작성 2시간, 코드 구현 15분이 걸렸다고 할 때 과연 2시간이 얼마나 가치있었다고 할 수 있을까? 누군가는 의문을 가질지도 모른다. 그러나 단순히 구현에 15분이 걸렸다고 한들, 그것을 제대로 검증하지 않았을 때 발생하는 디버깅, 코드 변경 등에 발생하는 시간 손실을 생각해본다면 2시간은 상당한 가치가 있었다고 생각할 수 있다. 결론적으로 테스트 루틴의 사용은 개발작업의 속도를 높이므로 대부분의 개발팀에게 중요하다고 말할 수 있다. 기능추가에 시간이 얼마나 걸릴지 모르거나, 주어진 시간이 많지 않을 때, 가급적 가장 빠른 방법으로 기능을 구현하려는 유혹에 빠지기 쉽다. 나중에 리팩토링 하거나 테스트하자고 생각하기 때문이다. 이것은 의지의 문제이기도 하다. 

결국 이것은 현실 세계에서의 딜레마다. 지금 시간을 투자할 것인지, 나중에 투자할것인지. 레거시 코드의 경우에는 많은 의존관계로 인해 테스트 코드를 작성하기 어렵다. 여기서는 완전히 새로운 코드를 작성함으로써 대처하는 방법을 알아본다.

### 발아 메소드
변경하고자 하는 코드의 테스트는 어렵더라도, 새롭게 추가하는 코드에 대해서는 테스트 루틴을 작성할 수 있다. 새로운 코드를 별도의 함수로 분리한다음에 해당 함수에 대한 테스트 루틴을 작성하는 것이다. 이를 발아 메소드라고 하는데 발아 메소드의 작성 순서는 다음과 같다.
* 코드 변경 필요한 부분 식별
* 신규 메소드 호출하는 코드 작성 후 주석 처리 (메소드 호출 부분을 먼저 작성)
* 호출되는 메소드가 필요로하는 지역 변수를 확인하고, 인자로 전달
* 메소드에 값을 반환해야 하는 여부 결정.
* 새롭게 추가한 메소드에 대해 테스트 주도 개발 방법을 적용해 작성
* 주석 처리 해제

독립된 하나의 기능을 추가하거나, 테스트 루틴이 준비되지 않은 경우에는 발아 메소드가 잘 사용될 수 있다. 발아 메소드의 장단점은 다음과 같다. 
* 단점: 원래 메소드와 클래스를 잠시 포기하는 것과 같다. 새롭게 추가하는 부분에 대한 테스트 루틴을 작성하는 것이므로, 기존 코드는 여전히 테스트 하네스가 없는 상태이다. 이는 나중에 추가 작업을 해야 함을 의미한다.
* 장점: 기존 코드와 새로운 코드를 확실히 구분할 수 있다. 또한 기존 코드를 테스트 루틴으로 보호할 순 없지만, 적어도 새로운 코드는 부분적으로 보호할 수 있다.

### 포장 메소드 & 클래스
일종의 데코레이터 패턴을 이용한 리팩토링. 포장 메소드는 기존 메소드의 전후에 기능을 추가하고자 할 때 사용할 수 있다. 포장 메소드는 봉합부를 추가하는데도 유용하다. 단 기존 기능의 이전이나 이후에 수행되어야 한다던지 기존 코드의 새로운 이름을 고안해야 한다는 점이 단점이다. 
* 변경해야 할 메소드를 식별한다.
* 메소드 이름을 바꾸고 기존 메소드와 동일한 이름과 서명을 갖는 메소드를 새로 작성한다.
* 새로운 메소드에서 기존 메소드를 호출하도록 한다.
* 새로운 기능을 위한 메소드를 테스트 주도 개발을 통해 작성하고, 이 메소드를 단계 2에서 작성한 신규 메소드에서 호출한다.
포장 클래스는 추가하려는 동작이 완전히 독립적이고, 기존 클래스를 오염시키고 싶지 않은경우, 클래스가 너무 비대해져서 더 이상 키우고 싶지 않은 경우에 사용을 고려한다.
  
단순한 기능 추가를 위해 포장 클래스를 사용하는것은 처음에는 복잡해보일 수 있다. 그러나 이런 리팩토링된 코드가 쌓이기 시작하면 어느 순간 좋은 코드와 나쁜 코드의 차이를 직감적으로 이해하게 된 순간이 온다.
