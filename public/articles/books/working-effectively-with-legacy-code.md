### 소프트웨어 변경
* 소프트웨어 코드 변경 이유
    * 새로운 기능 추가
    * 버그 수정
    * 설계 개선
    * 자원 이용의 최적화
* 소프트웨어 코드 변경을 숙지하고 있는것은 우리가 무엇에 집중해야 하는지 알려주는 이점이 있다.
* 하지만 변경 코드에만 집중해서는 안된다. 정말 문제가 되는 것은 코드를 변경할 때 어떤 동작에 영향을 미칠지 파악하기 매우 어려운 점이다.
* 위험한 변경을 최소화하기 위해 세가지 질문을 해야 한다.
    * 어떤 변경을 해야 하는가?
    * 변경이 정확하게 이루어졌는지 어떻게 확인 할 수 있는가?
    * 무언가를 손상시키지 않았는지를 어떻게 확인 할 수 있는가?
* 이런 위험이 크다면 구성원은 변경 회피를 하게 된다. 이런 변경 회피는 두려움이라는 문제로 다가온다. 그러나 변경을 회피하는 것은 나쁜 결과를 초래한다.
    * 기존의 클래스와 메소드는 비대해져갈 것 이다.
    * 개발자의 실력이 녹슬기 쉬워진다.
    * 변경 회피에 대한 두려움이 더 커진다.

### 피드백 활용
* 시스템을 변경하는 방법은 크게 2가지가 있다.
    * 변경하고 기도하기 (기도메타)
    * 보호 후 수정하기 (Cover and modify)
* 보호 후 수정하기는 안전망을 이용하는 것이다. 소프트웨어에 안전망을 두르는것은 데스트 루틴으로 코드를 덮는것이다.
* 피드백은 빠른 것이 좋다.
    * QA 팀이 발견해서 당신에게 이슈를 어사인하기까지는 시간이 걸린다.
    * 테스트 코드가 있다면, 당신은 몇 분만에 문제점이 있다는 것을 알 수 있다.
* 단위테스트
    * 시스템의 가장 원자적인 동작 단위를 의미
    * 함수나 클래스의 분리 테스트는 단위 테스트의 의미상 매우 중요
    * 단위테스트에 비해 대규모 테스트는 어려움이 있다.
        * 오류 위치를 파악하기가 어렵다.
        * 오랜 시간이 걸린다. 오래 걸리는 테스트는 결국 실행하지 않게 된다.
        * 새로운 코드가 추가된 경우, 그 코드를 실행하기 위한 상위 단계 테스트 루틴을 작성하기 위해 상당량의 코딩 작업이 요구 될 수 있다.
    * 단위테스트는 대규모 테스트의 단점을 보완할 수 있다. 단위테스트의 조건은 아래와 같다.
      * 실행 속도가 빠르다. 실행시간이 0.1초 이상 걸린다면 속도가 느리다!
      * 오류 위치 파악에 도움이 된다.
    * 아래의 경우는 단위 테스트가 아니다. 이런 테스트는 단위 테스트와 분리할 수 있어야 한다.
        * 데이터베이스 연동
        * 네트워크를 통해 통신
        * 파일 시스템을 사용
        * 테스트 실행을 위해 특별한 작업(e.g. 설정파일 변경) 을 해야 한다.
* 레거스 코드 프로젝트에서 변경 작업을 해야 한다면, 변경을 할 코드 주변에 테스트 루틴을 배치하자. 이것은 언제나 안전성을 높여줄 것이다.
* 레거시 코드를 변경하는 순서는 아래와 같다.
    * 변경 지점을 식별한다.
    * 테스트 루틴을 작성할 위치를 찾는다.
    * 의존 관계를 제거한다.
    * 테스트 루틴을 작성한다.
    * 변경 및 리팩토링을 수행한다. (TDD를 적극 권장한다)
    
### 감지와 분리
