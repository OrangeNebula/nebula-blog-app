### 소프트웨어 변경
* 소프트웨어 코드 변경 이유
    * 새로운 기능 추가
    * 버그 수정
    * 설계 개선
    * 자원 이용의 최적화
* 소프트웨어 코드 변경을 숙지하고 있는것은 우리가 무엇에 집중해야 하는지 알려주는 이점이 있다.
* 하지만 변경 코드에만 집중해서는 안된다. 정말 문제가 되는 것은 코드를 변경할 때 어떤 동작에 영향을 미칠지 파악하기 매우 어려운 점이다.
* 위험한 변경을 최소화하기 위해 세가지 질문을 해야 한다.
    * 어떤 변경을 해야 하는가?
    * 변경이 정확하게 이루어졌는지 어떻게 확인 할 수 있는가?
    * 무언가를 손상시키지 않았는지를 어떻게 확인 할 수 있는가?
* 이런 위험이 크다면 구성원은 변경 회피를 하게 된다. 이런 변경 회피는 두려움이라는 문제로 다가온다. 그러나 변경을 회피하는 것은 나쁜 결과를 초래한다.
    * 기존의 클래스와 메소드는 비대해져갈 것 이다.
    * 개발자의 실력이 녹슬기 쉬워진다.
    * 변경 회피에 대한 두려움이 더 커진다.

### 피드백 활용
* 시스템을 변경하는 방법은 크게 2가지가 있다.
    * 변경하고 기도하기 (기도메타)
    * 보호 후 수정하기 (Cover and modify)
* 보호 후 수정하기는 안전망을 이용하는 것이다. 소프트웨어에 안전망을 두르는것은 데스트 루틴으로 코드를 덮는것이다.
* 피드백은 빠른 것이 좋다.
    * QA 팀이 발견해서 당신에게 이슈를 어사인하기까지는 시간이 걸린다.
    * 테스트 코드가 있다면, 당신은 몇 분만에 문제점이 있다는 것을 알 수 있다.
* 단위테스트
    * 시스템의 가장 원자적인 동작 단위를 의미
    * 함수나 클래스의 분리 테스트는 단위 테스트의 의미상 매우 중요
    * 단위테스트에 비해 대규모 테스트는 어려움이 있다.
        * 오류 위치를 파악하기가 어렵다.
        * 오랜 시간이 걸린다. 오래 걸리는 테스트는 결국 실행하지 않게 된다.
        * 새로운 코드가 추가된 경우, 그 코드를 실행하기 위한 상위 단계 테스트 루틴을 작성하기 위해 상당량의 코딩 작업이 요구 될 수 있다.
    * 단위테스트는 대규모 테스트의 단점을 보완할 수 있다. 단위테스트의 조건은 아래와 같다.
      * 실행 속도가 빠르다. 실행시간이 0.1초 이상 걸린다면 속도가 느리다!
      * 오류 위치 파악에 도움이 된다.
    * 아래의 경우는 단위 테스트가 아니다. 이런 테스트는 단위 테스트와 분리할 수 있어야 한다.
        * 데이터베이스 연동
        * 네트워크를 통해 통신
        * 파일 시스템을 사용
        * 테스트 실행을 위해 특별한 작업(e.g. 설정파일 변경) 을 해야 한다.
* 레거스 코드 프로젝트에서 변경 작업을 해야 한다면, 변경을 할 코드 주변에 테스트 루틴을 배치하자. 이것은 언제나 안전성을 높여줄 것이다.
* 레거시 코드를 변경하는 순서는 아래와 같다.
    * 변경 지점을 식별한다.
    * 테스트 루틴을 작성할 위치를 찾는다.
    * 의존 관계를 제거한다.
    * 테스트 루틴을 작성한다.
    * 변경 및 리팩토링을 수행한다. (TDD를 적극 권장한다)
    
### 감지와 분리

## 봉합 모델
단위 테스트를 위해 개별 클래스를 추출하려고 하면 대부분 수많은 의존 관계를 제거해야 한다. 
봉합 지점은 코드를 직접 편집하지 않고도 프로그램의 동작을 변경할 수 있는 위치를 말하는데, 이를 이용하면 테스트 코드를 작성할 수 있다.

또한 봉합에는 활성화 지점이 있다. 활성화 지점이란, 어떤 동작을 사용할 지 선택할 수 있는 지점이다. 봉합이 있다는 것은 동작을 변경시킬 수 있는 지점을 의미하는데, 우리가 실행할 코드의 변경 없이 동작을 변경한다는 것은 실행할 코드 이외에 지점에서 코드를 변경해야 한다는 의미이다. 그리고 그 지점이 바로 봉합의 활성화 지점이라 볼 수 있다.

### 전처리 봉합

### 링크 봉합
자바의 경우 CLASSPATH 를 통해 어떤 클래스를 사용할 것인지 결정할 수 있는 봉합을 이용할 수 있다. CLASSPATH 를 변경하는 것은 번거로운 일일 수 있지만, 의존관계를 제거하는데는 매우 유용하다.

혹은 특정 라이브러리를 임포트하고 있다면, 해당 라이브러리에 대한 스텁을 만들어서 사용하도록 함으로써 의존관계를 제거할 수 있다.

링크 봉합의 활성화 지점은 언제나 소스 코드의 외부에 위치한다. 링크봉합을 사용할 때는 테스트 환경과 제품(배포) 환경 간에 분명한 차이가 있도록 구성해야 한다.

### 객체 봉합
추상 클래스를 구현하는 여러 구상 클래스를 두면, 어떤 메소드가 실행이 될 지 알 수 없다. 즉 다른 코드의 변경 없이 호출되는 메소드의 액션을 변경시킬 수 있는 위치가 되는데, 이는 봉합 위치라고 볼 수 있다. 그러나 추상 클래스가 아니라 구상 클래스에 의존하게 되면, 이는 어떤 메소드가 호출될 것인지 직접적으로 알 고 있으므로 봉합 지점이 아니다.

### 
