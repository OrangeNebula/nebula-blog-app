순차적으로 명령어를 입력해서 실행되는 언어-> 절차지향
=> 절차지향 언어, C언처

절차지향 -> 복잡도가 증가하면서 비효율이 발생함. 비효율이란, 유지보수 개발기간 등 다양한 부분

효과적인 개발방식을 찾기 위해 객체지향 패러다임이 나옴.

객체지향은 현실의 사물(=객체)를 모델링하여 이들의 행위와 속성을 정의(=객체)하고 그 실제 사물이 동작하는 방식으로 설계


객체는

상태 유지, 기능 제공, 고유 식별자 제공 3가지 요소가 있다
객체는 상태 정보를 저장하고, 유지, 속성은 변수로 정의된다.
속성값이 바뀜으로 상태가 변경될 수 있다

객체는 기능을 제공한다. 캡슐화와 연관이 있고, 객체는 메소드로 기능을 제공한다.

객체는 고유한 식별자를 가져야 한다(?)

----------------

캡슐화  
-> 추상화를 실현할 수 있다. (외부에서 내부 동작을 이해할 필요가 없다)  
-> 재 사용성을 향상할 수 있다.  
-> 유지보수 효율성이 향상된다.  
(절차지향이였다면, 메소드 수정시 메소드가 미치는 영향을 모두 체크해야 한다. 그러나 객체의 경우 단일 객체에만 영향을 주기 때문에 재사용성이 높다)  
-> 무결성, 정해진 인터페이스를 통해서만 객체의 속성을 변경할 수 있으므로, 값에 대한 유효성을 보증할 수 있다.  

상속  
-> 상속은 하위로 내려갈 수록 구체화가 된다.  
-> 재사용성 향상. 상위 클래스에 있는 메소드를 사용할 수 있다.  
-> 상속을 통해 프로그램을 확장할 수 있다.  
-> 유지보수성 향상.  
==> 실무적 관점에서 비판적으로 생각해봐야 할 부분이 있을듯  

다형성  
-> 행위를 각 하위객체에서 다양한 형태로 재정의할 수 있다.


추상화  
-> 객체지향에서 추상화는 모델링  
-> 공통적인 부분, 특정 특성을 분리해서 재조합 하는 부분이 추상화  
-> 다형성, 상속 모두 추상화에 속한다  
==> 이렇게 간단히 정의될 수 있는걸까?  


-------

결합도는 낮추고 응집도는 높여햐 한다.

SRP 단일 책임원칙  


OCP 개방 폐쇄 원칙  
자신의 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.  


LSP 리스코프 치환원칙
서브 타입은 언제나 자신의 상위 타입으로 교체 할 수 있어야 한다.  

ISP 인터페이스 분리 원칙  
클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다. 


DIP 의존 역전 원칙
자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
(좀 더 설명을 추가해야 함... too simplified)  

--------------

POJO (Plain Old Java Object)  
* 특정 규약에 종속되지 않는다. 특정 라이브러리, 모듈의 클래스를 상속 받아서 구현하지 않아도 된다.  
* 특정 환경에 종속되지 않는다. 외부 종속적인(http, request, session) 등을 사용할 경우 POJO를 위반한다고 볼 수 있다.  

spring, hibernate 두 프레임워크는 객체지향적인 설계, POJO 를 지향하고 있다. 서비스 로직에 집중하고 이를 POJO 로 쉽게 개발할 수 있도록 지원한다.





