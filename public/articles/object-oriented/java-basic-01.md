순차적으로 명령어를 입력해서 실행되는 언어-> 절차지향
=> 절차지향 언어, C언처

절차지향 -> 복잡도가 증가하면서 비효율이 발생함. 비효율이란, 유지보수 개발기간 등 다양한 부분

효과적인 개발방식을 찾기 위해 객체지향 패러다임이 나옴.

객체지향은 현실의 사물(=객체)를 모델링하여 이들의 행위와 속성을 정의(=객체)하고 그 실제 사물이 동작하는 방식으로 설계


객체는

상태 유지, 기능 제공, 고유 식별자 제공 3가지 요소가 있다
객체는 상태 정보를 저장하고, 유지, 속성은 변수로 정의된다.
속성값이 바뀜으로 상태가 변경될 수 있다

객체는 기능을 제공한다. 캡슐화와 연관이 있고, 객체는 메소드로 기능을 제공한다.

객체는 고유한 식별자를 가져야 한다(?)

----------------

캡슐화  
-> 추상화를 실현할 수 있다. (외부에서 내부 동작을 이해할 필요가 없다)  
-> 재 사용성을 향상할 수 있다.  
-> 유지보수 효율성이 향상된다.  
(절차지향이였다면, 메소드 수정시 메소드가 미치는 영향을 모두 체크해야 한다. 그러나 객체의 경우 단일 객체에만 영향을 주기 때문에 재사용성이 높다)  
-> 무결성, 정해진 인터페이스를 통해서만 객체의 속성을 변경할 수 있으므로, 값에 대한 유효성을 보증할 수 있다.  

상속  
-> 상속은 하위로 내려갈 수록 구체화가 된다.  
-> 재사용성 향상. 상위 클래스에 있는 메소드를 사용할 수 있다.  
-> 상속을 통해 프로그램을 확장할 수 있다.  
-> 유지보수성 향상.  
==> 실무적 관점에서 비판적으로 생각해봐야 할 부분이 있을듯  

다형성  
-> 행위를 각 하위객체에서 다양한 형태로 재정의할 수 있다.


추상화  
-> 객체지향에서 추상화는 모델링  
-> 공통적인 부분, 특정 특성을 분리해서 재조합 하는 부분이 추상화  
-> 다형성, 상속 모두 추상화에 속한다  
==> 이렇게 간단히 정의될 수 있는걸까?  


-------

결합도는 낮추고 응집도는 높여햐 한다.

SRP 단일 책임원칙  


OCP 개방 폐쇄 원칙  
자신의 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.  


LSP 리스코프 치환원칙
서브 타입은 언제나 자신의 상위 타입으로 교체 할 수 있어야 한다.  

ISP 인터페이스 분리 원칙  
클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다. 


DIP 의존 역전 원칙
자신보다 변하기 쉬운 것에 의존하지 말아야 한다.
(좀 더 설명을 추가해야 함... too simplified)  

--------------

POJO (Plain Old Java Object)  
* 특정 규약에 종속되지 않는다. 특정 라이브러리, 모듈의 클래스를 상속 받아서 구현하지 않아도 된다.  
* 특정 환경에 종속되지 않는다. 외부 종속적인(http, request, session) 등을 사용할 경우 POJO를 위반한다고 볼 수 있다.  

spring, hibernate 두 프레임워크는 객체지향적인 설계, POJO 를 지향하고 있다. 서비스 로직에 집중하고 이를 POJO 로 쉽게 개발할 수 있도록 지원한다.


---------------

디자인 패턴
* 개발자 간의 원활한 소통  
* 소프트웨어 구조 파악 용이  
* 재사용을 통한 개발 시간 단축
* 설계 변경 요청에 대한 유연한 대처

단점
*  객체지향 설계 / 구현, 이해도
*  초기 투자 비용  

생성 패턴
* 객체 생성과 관련된 패턴, 객체의 생성과 변경이 전체 시스템에 미치는 영향을 최소화 하고, 유연성을 높임
* 팩토리 싱글톤 프로포타입, 빌더 등

구조패턴  
프로그램내의 자료구조나 인터페이스 등 프로그램 구조를 설계하는데 활용 될 수 있는 패턴. 클래스, 객체들의 구성을 통해서 더 큰 구조를 만들 수 있게 해줌.
* 어댑터, 컴포짓, 브릿지, 데코레이터, 파사드, 플라이웨이트, 프록시 패턴

행위패턴
반복적으로 사용되는 객체들의 상호작용을 패턴화. 객체들의 상호작용하는 방법과 책임을 분산
* 템플릿, 인터프리터, 아이터레이터, 옵저버, 전략 패턴, 미디에이터

------------

웹의 3가지 요소
URI, HTTP, HTML


---------
REST

* 클라이언트와 서버가 독립적으로 분리
* Stateless, 클라이언트 상태를 서버에 저장하지 않음
* 캐시, 서버 응답을 임시저장할 수 있고, 재사용가능하며, 이를 통해 서버 부하를 줄일 수 있다
* 계층화. 서버와 클라이언트 사이에 다양한 계층 형태로 구성이 가능해야 하며, 이를 확장할 수 있어야 한다.
* 인터페이스 일관성. 
* Code on Demand: 특정 기능을 서버로부터 클라이언트가 전달받아 코드를 실행 할 수 있어야 한다.

리소스의 식별  
메시지를 통한 리소스 조작  
자기서술적 메시지
 : 요청하는 데이터가 어떻게 처리되어져야 하는지 충분히 설명이 되어야 한다.
Application 상태에 대한 엔진으로써 하이퍼미디어
 : 클라이언트 요청에 대한 데이터만 응답 해주는 것이 아니라, 관련된 리소스에 대한 Link 정보까지 같이 포함되어야 한다.
 : 현업에서는 잘 쓰고 있지 않다. 서버로 전달되는 데이터를 클라이언트에서는 맵핑해서 사용하는데, 불필요한 정보까지 기술해야 하는 로드가 발생할 수 있으므로. (git, slack, twitter 등의 Open API 에서는 이런 하이퍼미디어를 잘 사용하는것으로 보이는데, 어떤 이점이 있는지, 어떻게 활용할 수 있는지 확인 필요)

--------------
URI 설계 패턴

* 명사는 단수보다는 복수를 사용한다. 컬렉션은 특히  
* 컨트롤러는 동사로 표현한다. 
* 경로 중 변하는 부분은 유일한 값으로 대체한다. (e.g. /users/10)
* URI 쿼리 파라미터는, 컬렉션 결과를 필터링하는데 사용할 수 있다.

--------------

HTTP Protocol


